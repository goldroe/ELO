Buzz :: struct {
    x: s32;
    y: s32;
}

Foo :: struct {
    buzz1: Buzz;
    buzz2: Buzz;
}

Cell :: struct {
    live: bool;
}

main :: () -> s32 {
    printf("hello world! ");
    printf("%d %d", 100, 1001);
    
    foo: Foo;
    fp: *Foo = *foo;
    fp.buzz1.x = 1002;
    fp = null;

    printf("%p ", fp);

    while 1 {
    }

    fp.buzz1.y = 0;
    fp.buzz2.x = fp.buzz2.y = 10002;

    numbers := .{19,5,17,6,90,52,31,67,79,57};

    // for i := 0; i < 10; i += 1 {
    //     numbers[i] = i + 1;
    // }
    // for i in numbers {
    //     numbers[i] = 0;
    // }
    // for numbers {
    //     numbers[it] = 0;
    // }

    grid: [64][64]Cell;

    grid[10][10].live = false;

    map_width := 64;
    map_height := 64;

    for y := 0; y < map_height; y += 1 {
        for x := 0; x < map_width; x += 1 {
            live := 0;
            cell := *grid[y][x];

            if y > 0 {
                live = live + grid[y-1][x].live;
                if x > 0 {
                    live = live + grid[y-1][x-1].live;
                }
                if x < map_width - 1 {
                    live = live + grid[y-1][x+1].live;
                }
            }

            if y < map_height - 1 {
                live = live + grid[y + 1][x].live;
                if x > 0 {
                    live = live + grid[y+1][x-1].live;
                }
                if x < map_width - 1 {
                    live = live + grid[y+1][x+1].live;
                }
            }

            if x > 0 {
                live = live + grid[y][x-1].live;
            }

            if x < map_width - 1 {
                live = live + grid[y][x + 1].live;
            }

            if live < 2 {
               cell.live = false;
            }
            if live > 3 {
                cell.live = false;
            }
            if live == 2 {
                cell.live = true;
            }
            live += 1;
        }
    }

    return 0;
}

sum :: (n: int) -> int {
    s := 0;
    for x := 0; x <= n; x += 1 {
        s += x;
    }
    return s;
}

