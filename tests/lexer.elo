#load "stdlib.elo"
#load "stdio.elo"

Token_Kind :: enum {
    EOF,
    NAME,
    NUMBER,
    DOT,
    COMMA,
}

Token :: struct {
    kind: Token_Kind;
    line: int;
    col:  int;
    lexeme: *u8;
    integer: u64;
}

Lexer :: struct {
    stream: *u8;
    tok: Token;
}

is_space :: (ch: u8) -> bool {
    ifcase ch {
    case:
        return false;
    case ' ': #through case '\t': #through case '\f': #through case '\v': #through case '\n': #through case '\r':
        return true;
    }
}

is_alpha :: (ch: u8) -> bool {
    return 'A' <= ch && ch <= 'Z' || 'a' <= ch && ch <= 'z';
}

advance :: (lexer: *Lexer) {

    // skip whitespace
    while (is_space(lexer.stream.*)) {
        lexer.stream += 1;
    }

    start := lexer.stream;

    ifcase lexer.stream.* {
    case 0u8:
        lexer.tok.kind = Token_Kind.EOF;
    case 'a'..'z': #through case 'A'..'Z': #through case '_':
        lexer.tok.kind = Token_Kind.NAME;
        while is_alpha(lexer.stream.*) {
            lexer.stream += 1;
        }
    }
}

main :: () -> int {
    stream := "This is some text. 1 21 1223.\n New line okay cool.";
    lexer: Lexer;
    lexer.stream = stream;
    advance(*lexer);
    return 0;
}